<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BC</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        background-color: #f0f0f0;
        padding: 20px;
      }

      pre {
        background-color: #1e1e1e;
        color: #dcdcdc;
        padding: 15px;
        border-radius: 5px;
        overflow-x: auto;
      }

      h1 {
        text-align: center;
      }
    </style>
  </head>

  <body>
    <h1>Exp 04 (Simple Account creation)</h1>
    <pre><code class="language-python">
      // SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimpleAccount {
    address public daniyal;

    constructor() {
        daniyal = msg.sender;
    }
    function getOwner() public view returns (address) {
        return daniyal;
    }
}


    </code></pre>
    <h1>Exp 05 (Account Balance Checker)</h1>
    <pre><code class="language-python">
   // SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract BalanceChecker {
    function getBalance(address _address) public view returns (uint256) {
        return _address.balance;
    }
}

steps to deploy:
1. Open Remix IDE (https://remix.ethereum.org/).
2. Create a new file and paste the above code.
3. Compile the contract using the Solidity compiler.
4. Deploy the contract using the "Deploy & Run Transactions" tab.

    </code></pre>
    <h1>Exp 06 (Wallet Transactions)</h1>
    <pre><code class="language-python">
 // SPDX-License-Identifier: MIT
pragma solidity >=0.7.0 <0.9.0;

contract DBank {
    address public Owner;

    // Mapping for storing balances
    mapping(address => uint) private Balance;

    // Constructor to set the owner
    constructor() {
        Owner = msg.sender;
    }

    // Function for adding Ethereum in account
    function addBalance(uint amount) public returns (uint) {
        // Only owner can add balance
        require(msg.sender == Owner, "Only owner can add balance!");
        Balance[msg.sender] += amount;
        return Balance[msg.sender];
    }

    // Function to get the balance of the caller
    function getBalance() public view returns (uint) {
        return Balance[msg.sender];
    }

    // Function to transfer amount from sender to recipient
    function transfer(address recipient, uint amount) public {
        require(msg.sender != recipient, "Cannot transfer to self!");
        require(Balance[msg.sender] >= amount, "Insufficient balance!");

        _transfer(msg.sender, recipient, amount);
    }

    // Internal transfer logic
    function _transfer(address from, address to, uint amount) private {
        Balance[from] -= amount;
        Balance[to] += amount;
    }
}

        
    
            </code></pre>
               <h1>Exp 07 (Lottery)</h1>
    <pre><code class="language-python">
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

contract Lottery {
    address public owner;
    address payable[] public players;
    uint public lotteryId;
    mapping (uint => address payable) public lotteryhistory;

    // A modifier to restrict function access to only the contract owner
    modifier onlyOwner() {
        require(msg.sender == owner, "Only the contract owner can call this function.");
        _; // Placeholder for the function body
    }

    // Constructor: Runs once upon contract deployment
    constructor() {
        owner = msg.sender;
        lotteryId = 1; // Start with lottery ID 1
    }

    // Function to get the winner of a specific, past lottery
    function getWinnerByLottery(uint _lotteryId) public view returns (address payable) {
        return lotteryhistory[_lotteryId];
    }

    // Function for a player to enter the lottery
    // It must be marked 'payable' to accept Ether
    function enter() public payable {
        // Require a minimum entry fee of 0.01 Ether
        require(msg.value >= 0.01 ether, "Minimum entry fee is 0.01 Ether.");
        // Add the player's address to the list of players
        players.push(payable(msg.sender));
    }

    // A simple (but not cryptographically secure) way to get a "random" number
    // WARNING: This is predictable on the blockchain and should not be used
    // for high-value applications.
    function getRandomNumber() public view returns (uint) {
        // Combines owner address and current timestamp for a "seed"
        return uint(keccak256(abi.encodePacked(owner, block.timestamp, players.length)));
    }

    // Function to pick a winner, only callable by the contract owner
    function pickWinner() public onlyOwner {
        // Ensure there are players to pick from
        require(players.length > 0, "No players entered the lottery.");

        // 1. Get a random index from the players array
        uint index = getRandomNumber() % players.length;
        address payable winner = players[index];

        // 2. Transfer the entire contract balance (the prize pool) to the winner
        // Using call is generally preferred for transfers, but transfer is
        // simpler for this basic example.
        (bool success, ) = winner.call{value: address(this).balance}("");
        require(success, "Payment to winner failed.");

        // 3. Record the winner and increment the lottery ID for the next round
        lotteryhistory[lotteryId] = winner;
        lotteryId++;

        // 4. Reset the state of the contract for the next lottery
        // Resetting the players array
        delete players;
    }

    // Function to view the current list of players
    function getPlayers() public view returns (address payable[] memory) {
        return players;
    }

    // Function to view the current prize pool balance of the contract
    function getBalance() public view returns (uint) {
        return address(this).balance;
    }
}

            </code></pre>
  </body>
</html>
